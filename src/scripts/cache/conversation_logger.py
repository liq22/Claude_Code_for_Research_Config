#!/usr/bin/env python3
"""
Conversation Logger - Markdown Format

Generates human-readable conversation logs in Markdown format.
Creates daily conversation files that are easy to read and browse.

Author: Claude Code Research System
Version: 1.0.0
"""

import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ConversationLogger:
    """Human-readable conversation logger"""
    
    def __init__(self, base_path: str = "src/dev/cache"):
        self.base_path = Path(base_path)
        self.conversations_path = self.base_path / "conversations"
        self.conversations_path.mkdir(parents=True, exist_ok=True)
        
        # Create index file
        self.index_file = self.conversations_path / "README.md"
        self._ensure_index_file()
    
    def _ensure_index_file(self):
        """Ensure index file exists with header"""
        if not self.index_file.exists():
            with open(self.index_file, 'w', encoding='utf-8') as f:
                f.write("""# üìö Conversation History

This directory contains human-readable conversation logs in Markdown format.

## Files
- Each day gets its own file: `YYYY-MM-DD.md`
- Sessions are organized chronologically
- Full formatting is preserved (emoji, lists, code blocks)

## Navigation
- **Recent conversations**: Check the latest date files
- **Search**: Use your text editor's search across all `.md` files
- **Browse**: Files are organized by date for easy browsing

---

""")
    
    def _get_daily_log_path(self, date: datetime = None) -> Path:
        """Get path for daily conversation log"""
        if date is None:
            date = datetime.now()
        
        filename = date.strftime('%Y-%m-%d.md')
        return self.conversations_path / filename
    
    def _format_timestamp(self, timestamp: str = None) -> str:
        """Format timestamp for display"""
        if timestamp:
            try:
                dt = datetime.fromisoformat(timestamp)
                return dt.strftime('%H:%M:%S')
            except:
                pass
        
        return datetime.now().strftime('%H:%M:%S')
    
    def _ensure_daily_header(self, log_path: Path, date: datetime):
        """Ensure daily log has proper header"""
        if not log_path.exists():
            with open(log_path, 'w', encoding='utf-8') as f:
                date_str = date.strftime('%Y-%m-%d (%A)')
                f.write(f"""# üìÖ Conversation Log - {date_str}

> Generated by Claude Code Cache System

---

""")
    
    def log_user_prompt(self, session_id: str, prompt: str, timestamp: str = None) -> bool:
        """Log user prompt to daily conversation log"""
        try:
            now = datetime.now()
            log_path = self._get_daily_log_path(now)
            self._ensure_daily_header(log_path, now)
            
            time_str = self._format_timestamp(timestamp)
            
            with open(log_path, 'a', encoding='utf-8') as f:
                f.write(f"""## {time_str} - üë§ User

{prompt}

""")
            
            logger.info(f"User prompt logged to {log_path.name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to log user prompt: {e}")
            return False
    
    def log_claude_response(self, session_id: str, response: str, tools_used: list = None, timestamp: str = None) -> bool:
        """Log Claude's response to daily conversation log"""
        try:
            now = datetime.now()
            log_path = self._get_daily_log_path(now)
            self._ensure_daily_header(log_path, now)
            
            time_str = self._format_timestamp(timestamp)
            
            # Clean up response formatting
            response = response.strip()
            
            with open(log_path, 'a', encoding='utf-8') as f:
                f.write(f"""## {time_str} - ü§ñ Claude

{response}

""")
                
                # Add tools used if any
                if tools_used:
                    f.write(f"""<details>
<summary>üîß Tools Used ({len(tools_used)})</summary>

""")
                    for tool in tools_used:
                        if isinstance(tool, dict):
                            tool_name = tool.get('name', 'Unknown')
                            f.write(f"- **{tool_name}**\n")
                        else:
                            f.write(f"- {tool}\n")
                    
                    f.write("\n</details>\n\n")
                
                # Add session separator
                f.write("---\n\n")
            
            logger.info(f"Claude response logged to {log_path.name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to log Claude response: {e}")
            return False
    
    def log_tool_execution(self, session_id: str, tool_name: str, tool_input: dict, tool_output: dict = None, timestamp: str = None) -> bool:
        """Log tool execution to conversation log"""
        try:
            now = datetime.now()
            log_path = self._get_daily_log_path(now)
            self._ensure_daily_header(log_path, now)
            
            time_str = self._format_timestamp(timestamp)
            
            with open(log_path, 'a', encoding='utf-8') as f:
                f.write(f"""### {time_str} - üîß Tool: {tool_name}

""")
                
                # Show key input parameters
                if tool_input:
                    key_params = {}
                    for key in ['file_path', 'command', 'pattern', 'description']:
                        if key in tool_input:
                            key_params[key] = tool_input[key]
                    
                    if key_params:
                        f.write("**Parameters:**\n")
                        for key, value in key_params.items():
                            # Truncate long values
                            if isinstance(value, str) and len(value) > 100:
                                value = value[:100] + "..."
                            f.write(f"- `{key}`: {value}\n")
                        f.write("\n")
                
                # Show output if available and not too long
                if tool_output and isinstance(tool_output, dict):
                    if 'content' in tool_output:
                        content = str(tool_output['content'])
                        if len(content) < 500:
                            f.write(f"**Output Preview:**\n```\n{content}\n```\n\n")
                        else:
                            f.write(f"**Output:** {len(content)} characters\n\n")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to log tool execution: {e}")
            return False
    
    def get_recent_conversations(self, days: int = 7) -> list:
        """Get list of recent conversation files"""
        conversation_files = []
        
        for md_file in sorted(self.conversations_path.glob("*.md"), reverse=True):
            if md_file.name == "README.md":
                continue
            
            try:
                # Parse date from filename
                date_str = md_file.stem
                file_date = datetime.strptime(date_str, '%Y-%m-%d')
                days_ago = (datetime.now() - file_date).days
                
                if days_ago <= days:
                    conversation_files.append({
                        'path': md_file,
                        'date': file_date,
                        'days_ago': days_ago,
                        'size': md_file.stat().st_size
                    })
                    
            except ValueError:
                continue  # Skip files that don't match date format
        
        return conversation_files
    
    def get_stats(self) -> Dict[str, Any]:
        """Get conversation logger statistics"""
        md_files = list(self.conversations_path.glob("*.md"))
        if self.index_file in md_files:
            md_files.remove(self.index_file)
        
        total_size = sum(f.stat().st_size for f in md_files)
        recent_files = self.get_recent_conversations(7)
        
        return {
            'total_conversation_files': len(md_files),
            'total_size_bytes': total_size,
            'total_size_mb': round(total_size / (1024 * 1024), 2),
            'recent_files_7days': len(recent_files),
            'conversations_path': str(self.conversations_path),
            'index_file': str(self.index_file)
        }

# Global instance
_conversation_logger = None

def get_conversation_logger(base_path: str = "src/dev/cache") -> ConversationLogger:
    """Get global conversation logger instance"""
    global _conversation_logger
    if _conversation_logger is None:
        _conversation_logger = ConversationLogger(base_path)
    return _conversation_logger

# Convenience functions
def log_user_prompt(session_id: str, prompt: str, timestamp: str = None) -> bool:
    """Log user prompt"""
    logger_instance = get_conversation_logger()
    return logger_instance.log_user_prompt(session_id, prompt, timestamp)

def log_claude_response(session_id: str, response: str, tools_used: list = None, timestamp: str = None) -> bool:
    """Log Claude response"""
    logger_instance = get_conversation_logger()
    return logger_instance.log_claude_response(session_id, response, tools_used, timestamp)

def log_tool_execution(session_id: str, tool_name: str, tool_input: dict, tool_output: dict = None, timestamp: str = None) -> bool:
    """Log tool execution"""
    logger_instance = get_conversation_logger()
    return logger_instance.log_tool_execution(session_id, tool_name, tool_input, tool_output, timestamp)

if __name__ == "__main__":
    # Test the conversation logger
    conv_logger = get_conversation_logger()
    
    # Test logging
    test_session = "test-session"
    
    print("Testing conversation logger...")
    
    # Test user prompt
    conv_logger.log_user_prompt(test_session, "Hello Claude, how are you?")
    
    # Test Claude response
    conv_logger.log_claude_response(test_session, """Hi! I'm doing great, thank you for asking. 

Here's what I can help you with:
- üìö Research assistance
- üíª Code development  
- üìù Writing and documentation
- üîç Analysis and problem-solving

What would you like to work on today?""", tools_used=['Read', 'Write'])
    
    # Test tool execution
    conv_logger.log_tool_execution(test_session, "Read", {"file_path": "test.py", "limit": 50}, {"content": "print('Hello World')"})
    
    # Show stats
    stats = conv_logger.get_stats()
    print(f"Logger stats: {stats}")
    
    print("‚úÖ Conversation logger test complete!")